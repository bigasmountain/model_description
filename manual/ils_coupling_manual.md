# Introduction to coupled calculations

This chapter provides an overview of coupled calculations. Readers who
have already conducted coupled calculations or are familiar with such
calculations can skip this chapter.

First, the physical aspects of a coupled calculation are described. The
weather/climate is formed through the interaction of multiple physical
elements, such as the atmosphere and ocean. For example, momentum from
the atmosphere to the ocean surface and sensible heat from the ocean
surface to the lower boundary of the atmosphere are transported().
Therefore, in a simulation model expressing these phenomena, it is
necessary to exchange physical quantities corresponding to them. At this
time, each model executes a calculation on an appropriate grid system
and time scale according to the physical phenomena represented by the
model. Therefore, to exchange data between models having mutually
different grid systems and time scales, appropriate time management and
grid remapping are required.

![Schematics of Atmosphere-Ocean interaction(from Encyclopedia of the
Environment,
https://www.encyclopedie-environnement.org/en/air-en/biosphere-hydrosphere-and-cryosphere-models/)](figs/ao_interaction.pdf){#fig:ao_interaction}

Next, a computational aspect of a coupled calculation is described.
Modern high-performance computers operate a plurality of arithmetic
units in parallel. When running a simulation model on a high-performance
computer, the model must correspond to the architecture of such a
computer. This correspondence is generally realized through a domain
decomposition that divides the model grid. In addition, in a coupled
calculation, a plurality of models are executed in parallel. Therefore,
when exchanging data, it is necessary to conduct a data exchange between
appropriate processes in consideration of a domain decomposition. shows
an example of such a data exchange. Here, it is assumed that model A has
an 8 × 8 grid, and model B has a 12 × 12 grid, and is divided into 4 × 4
and 3 × 3 regions, respectively. Each region is numbered as shown in the
figure. As indicated by the light green arrow, region 5 of model A
exchanges data with regions 0, 1, 3, and 4 of model B. By contrast, as
indicated by the dark green arrows, region 4 of model B exchanges data
with regions 6, 7, 10, and 11 of model A.

It is inappropriate to make individual software for conducting such a
complex data exchange for each model, and therefore dedicated software
for performing a coupled calculation is generally used. This software is
called a coupler or a coupling library.

As mentioned above, there are three main tasks for a coupler:

1.  Control of data exchange timing

2.  Grid remapping

3.  Data exchange between appropriate processes

![Schematic image of data exchange between domain decomposed
models.](fig_cpl/data_exchange_example.png){#fig:data_exchange_example}

# Introduction to ILS coupling

## About ILS Coupling System

An ILS is composed of multiple component models, such as a land surface
model, MATSIRO; a river model, CaMa-Flood; and a water resources model,
HO8. To couple these component models, an ILS uses Jcup as a coupling
library. Jcup is a general-purpose coupling library, and there are
almost no restrictions on its applicable grid systems and coupling
patterns. However, owing to its high flexibility, its interface is
complicated, making it difficult for beginners to use. Therefore, a
wrapper MOJ (MATSIRO Over Jcup) with a more compact interface customized
to an ILS was developed. MOJ features common to Jcup are summarized as
follows.

-   An arbitrary number of two or more components can be coupled

-   Each component can be coupled in series or in parallel

-   Each component is parallelized through a domain decomposition

-   Any grid system can be applied when it has a uniquely numbered grid

-   One component model can have multiple grid systems

-   An exchange time interval can be set for all data

-   Unlimited number of exchangeable data

-   Multiple data can be sent and received together based on the
    configuration

A user can couple one component model with another by calling the MOJ
API subroutines from the model and setting the configuration file.

## Coupling Overview
-----------------

### Communicator

Hereinafter, it is assumed that each component model uses an MPI and is
parallelized through a domain decomposition. A parallel program based on
an MPI executes parallel calculations with reference to a communicator.
The default communicator is MPI_COMM_WORLD, and there is no problem
using this default communicator when running on a single model. However,
when models are coupled using an MOJ, the communicator of each model is
generated by the MOJ, and it is therefore necessary to change the
communicator to one given by the MOJ. shows a communicator when the
component is used alone and a communicator when coupled with an MOJ. For
a single component, MPI_COMM_WORLD is used in all component processes.
By contrast, when coupled with an MOJ, MPI_COMM_WORLD is defined for all
processes of all coupled components, and the communicator of each
component is given by the MOJ. The communicator of each component can be
obtained through the MOJ API routine described later.

![MPI communicator with components alone and that coupled with an MOJ
(left figure; components alone; right figure; components coupled with an
MOJ)](fig_cpl/moj_mpi_comm.png){#fig:moj_mpi_comm}

### Coupling Pattern

An MOJ can combine two (or more) coupled models in series and in
parallel. Here, serial refers to a case in which two components pass
data during the same time step, and parallel refers to a case in which
two components pass data of a previous time step to each other. A
schematic diagram of both patterns is shown in . The left figure is a
serial coupling example, in which the calculation result of model A is
passed to model B during the same time step, and the calculation of
model B is conducted. In serial coupling, each model component waits for
the end of the calculation of the other component, and thus the overall
execution time is substantially equal to the sum of the execution times
of the two components. The right figure shows an example of a parallel
coupling, where the model component sends the calculation result to the
other side component at each time step, and receives the data of the
other side component at the next time step. In this case, the overall
execution time is approximately equal to the time of the component with
the longest execution time. The gray squares before $T_0$ indicate the
initial value exchange.

![Coupling pattern(left:serial coupling,right:parallel
coupling）](figs/coupling_pattern.pdf){#fig:coupling_pattern}

### Data Exchange

The data exchange time interval can be set for each data. In the example
shown in , model B exchanges data with model C every four steps, and
model A every five steps. At the time of a data exchange, each model
requires that the model time coincide with the data exchange time. Time
steps other than the data exchange time do not need to be constant.

![Data exchange
pattern](fig_cpl/data_exchange_pattern.png){#fig:data_exchange_pattern}

# Preparation

## Grid index table

Which region (MPI process) of the target component to which all grid
point data are exchanged is determined by the grid point index assigned
to each area of the component model and the mapping table described in
the next section.

The grid point index of the grid assigned to each region is given to the
coupler by the MOJ API subroutine moj_def_grid. The index must be made
up of natural numbers. In addition, it does not need to be continuous,
and a discrete number can be applied.

However, the numbers need to be unique among the grid points of all
regions. Because the coupler does not check for duplicate numbers, an
operation in the presence of duplicate grid points cannot be predicted.
One component can have a plurality of grids, and the number of grid
points and the grid point index of each grid can be set independently.

## Mapping table

An MOJ does not depend on the grid structure and can flexibly couple the
models whose grid does not change over time. However, for this purpose,
it is necessary to obtain the correspondence between grid indexes among
the models and the interpolation coefficients in advance. For example,
as shown in , the value of grid point R(p) of the receiving model is
calculated from grid points $S(i)-S(i+4)$ and coefficient
$Cs(i)-Cs(i+4)$, as shown the equation below:

$$R(p) = \sum_{n=0}^{4} Cs(i+n)*S(i+n)$$

The mapping table for $R(p)$ can be expressed as . For the vector
quantity, a coefficient expressing rotation is further added. These
values are given as arguments of the MOJ API subroutine
moj_set_interpolation_table to be described later.

![Grid points and coefficients on interpolation
calculation](fig_cpl/interpolation_image.png){#fig:interpolation_image}

``` {#list:mapping_table_sample caption="Example of mapping table" label="list:mapping_table_sample"}
R(p), S(i), Cs(i)
 R(p), S(i+1), Cs(i+1)
 R(p), S(i+2), Cs(i+2)
 R(p), S(i+3), Cs(i+3)
 R(p), S(i+4), Cs(i+4)
```

## Configuration file

To define the operation of an MOJ, it is necessary to create a
configuration file in advance. The name of the configuration file is
given by the MOJ API subroutine moj_init. What users need to set in the
configuration file are the coupler_config session, which specifies the
operation of the coupler, and the nam_moj session, which defines the
exchange data. The elements, descriptions, and possible values for each
session are summarized in and .

The session coupler_config consists of two elements, log_level and
debug_mode. Of these, log_level sets the detailedness (amount) of the
log output. Possible values include \"SILENT,\" \"WISPER,\" and
\"LOUD.\" The latter value outputs a more detailed log. Debug_mode is a
flag indicating whether to output a log. If debug_mode = .false., a log
is not output regardless of the log_level setting. Note that log_level =
\"LAUD\" outputs a large number of logs, and thus care must be taken
when performing long-term integration.

The session nam_moj describes the sending/receiving components, the
grid, and the data group exchanged between these components. A plurality
of data can be set for a pair of components and a grid, and all data are
interpreted as corresponding to the component and the grid described
immediately before. Settings that can be omitted are shown in italics in
the table.

Var_put and var_get are exchange data names, and var_put_vec and
var_get_vec are exchange vector data names. Either a scalar data name or
a vector data name must be specified. Mapping_tag is a tag for
specifying a mapping table. Time_intpl_tag is a data identification tag
for time interpolation, and data with the same numbered tag are passed
to the time interpolation subroutine of the IO component. This tag is
valid only when coupling IO components. Grid_intpl_tag is a data
identification tag for spatial interpolation, and data with the same
number are exchanged as a set of data and passed to the spatial
interpolation subroutine. Intvl sets the data exchange interval in
seconds. Lag sets the coupling pattern. When two components are coupled
in parallel, a value of -1 is given to both the sending and receiving
data, and when they are coupled in series, a value of 1 is given to the
preceding component and a value of -1 is given to the succeeding
component. In addition, 0 indicates a special setting, and is set only
when the initial data are acquired from the IO component using the API
subroutine moj_get_initial_data described later. Layer is an integer
indicating the number of vertical layers of data. Flag is a flag
indicating whether to calculate the time average internally, and
specifies \"SNP\" or \"AVR.\" Factor is a real constant that is
multiplied with the data at the spatial interpolation. Is_ok is a flag
indicating whether a data exchange is actually conducted. If is_ok = 1,
the data are exchanged, and if the value is 0, the data are not
exchanged. A sample of the configuration file is shown in .

[\[table:coupler_config\]]{#table:coupler_config
label="table:coupler_config"}

::: {#table:coupler_config}
  element name   description　               possible values
  -------------- --------------------------- -----------------------------------------
  log_level      log output level            one of \"SILENT,\" \"WISPER,\" \"LOUD\"
  debug_mode     Flag to output log or not   .true. or .false.

  : Elements of couple_config session of configuration file
:::

[\[table:nam_moj_comp\]]{#table:nam_moj_comp label="table:nam_moj_comp"}

::: {#table:nam_moj_comp}
  element name   description                            possible value
  -------------- -------------------------------------- ------------------------------
  comp_put       sending component name                 string of the component name
  comp_get       receiving component name               string of the component name
  grid_put       grid name of the sending component     string of the grid name
  grid_get       grid name of the receiving component   string of the grid name

  : Example of nam_moj section (component and grid setting)
:::

[\[table:nam_moj_var\]]{#table:nam_moj_var label="table:nam_moj_var"}

::: {#table:nam_moj_var}
  element name       description　                      possible value
  ------------------ ---------------------------------- ------------------------------------------
  var_put            send data name                     string of the name
  var_get            receive data name                  string of the name
  var_put_vec        send vector data name              string of the name
  var_get_vec        receive vector data name           string of the data name
  *mapping_tag*      mapping table tag                  integer for specifying the mapping table
  *time_intpl_tag*   time interpolation tag             integer for identifying the data
  *grid_intpl_tag*   spacial interpolation tag          integer for identifying the data
  intvl              data exchange interval             integer in second
  lag                coupling pattern                   -1 or 0 or 1
  *layer*            number of vertical layer           integer for vertical layer (default 1)
  flag               time averaging flag                \"SNP\" or \"AVR\"
  *factor*           value multiplied to the data       real(kind=8) (default 1)
  *is_OK*            flag to exchange the data or not   1 or 0 (default 1)

  : Example of nam_moj section (exchange data setting)
:::

``` {#list:moj_namelist_sample caption="Example of MOJ configuration" label="list:moj_namelist_sample"}
&coupler_config
  log_level = "LOUD"
  debug_mode  = .true.
&end


&nam_moj  comp_put = "MATIO",   comp_get = "MATSIRO",
          grid_put ='io_grid', grid_get ='matsiro_grid', /
&nam_moj  var_put = 'SWdown'    ,  var_get ='SWdown'    , time_intpl_tag = 1, grid_intpl_tag = 1, intvl=3600 ,  lag=-1, flag='SNP' /
&nam_moj  var_put = 'LWdown'    ,  var_get ='LWdown'    , time_intpl_tag = 2, grid_intpl_tag = 1, intvl=3600 ,  lag=-1, flag='SNP' /
&nam_moj  var_put = 'Rainf'     ,  var_get ='Rainf'     , time_intpl_tag = 2, grid_intpl_tag = 1, intvl=3600 ,  lag=-1, flag='SNP' /
```

# How to use the API subroutines

## Overview of their usage

To use the MOJ component model, make the API module moj_api available in
the use statement. A typical usage of the MOJ API routine is as follows:
. First, initialize the MOJ with moj_init, and make various settings
related to the MPI. Next, various information of the MPI set by the MOJ
is acquired by moj_get_comm_local and moj_get_irank_local. Set the grid
point index of each area of the component with moj_def_grid, and notify
the MOJ of the end of the setting with moj_end_grid_def. Set the mapping
table with moj_set_interpolation_table and give the initial time to the
MOJ with moj_init_time. Provide the initial value with moj_put_data if
necessary. Finally, tell the MOJ about the end of the join with
moj_finalize.

![Typical usage of MOJ API routines during the initialization
phase](fig_cpl/moj_usage_sample.png){#fig:moj_usage_sample}

The call and internal operation of the MOJ API in the time integration
loop are as shown in . There are three API routines used in the time
integration loop: moj_set_time, moj_get_data, moj \_put_data. Call
moj_set_time near the beginning of the time integration loop and give
the current time and $\Delta{T}$ to the MOJ. Data exchange and
interpolation calculations are conducted inside this routine. Obtain the
data of the target component with moj_get_data, execute the calculation,
and pass the result to the MOJ with moj_put_data. It should be noted
that these API routines must be called for every time step.

![Typical usage of MOJ API routines in the time integration
loop](fig_cpl/moj_time_integ.png){#fig:moj_time_integ}

## Initialize MOJ

First, initialize the MOJ with moj_init. The arguments are the name of
the component and the name of the configuration file. If the MPI
initialization subroutine MPI_Init is not called in the model component,
it is called inside this routine. Note that calling MPI_Init on the
model component after calling moj_init will result in a double call
error.

## Get MPI information

As shown by , the MPI communicator of each component when coupled by the
MOJ is generated inside the MOJ. Therefore, the communicator used when a
component calls an MPI routine must be the one generated by the MOJ. The
communicator generated by the MOJ can be obtained using the API function
moj_get_comm_local. In addition, the process number inside the component
can be obtained from the MOJ API routine.

## Set grid index

Set the grid point number with moj_def_grid. The arguments are a grid
name, a grid size $(nx, ny, nz)$, and a one-dimensional array
grid_index(:) of the grid point indexes. What should be noted here is
whether to include the vertical dimension in the array of the grid point
indexes to be given. For example, in the case of atmosphere-ocean
coupling, the exchange data are two-dimensional horizontally, and even
if a third dimension exists, in numerous cases, it is not a physical
vertical layer but a quantity such as a category. Further, even when
exchanging data such as atmosphere and chemistry coupling in a physical
three-dimensional space, the grid differs only in the horizontal plane,
and vertical interpolation may not be necessary in certain cases. When
the mapping table is expressed only in the horizontal plane as in these
examples, even if the data to be exchanged have a vertical layer, the
grid index setting is $nz = 1$, and the size of the grid_index is
$nx *ny$. The above is summarized as follows.

-   When the exchange data are horizontal 2D data or the interpolation
    calculation is horizontally 2D only

    nz = 1, and grid_index is given as an array of size $nx * ny$.

-   Interpolation calculation in 3D space including vertical

    grid_index is given as an array of size $nx * ny * nz$.

When exchanging 3D data including a vertical layer in the former case,
the number of vertical layers is given to the layer by setting
individual data in the setting file.

## Set mapping table

The mapping table setting subroutine moj_set_interpolation_table must be
called by both the sending component and the receiving component.
Because a data exchange is conducted inside this subroutine, the calling
location must correspond in the sending and receiving components.
Arguments after the grid point index are optional arguments and are
given by the receiving component. Further, when the data to be exchanged
are only of a scalar amount or there is no rotation of the grid, it is
not necessary to provide two arguments of coef_sin and coef_cos. The
above results are shown in .

[\[table:interpolation_table_arguments\]]{#table:interpolation_table_arguments
label="table:interpolation_table_arguments"}

::: {#table:interpolation_table_arguments}
  Arguments        meaning                     Criteria to give　
  ---------------- --------------------------- -------------------------------
  send_comp_name   send component name         
  send_grid_name   send grid name              give both
  recv_comp_name   receive component name      component
  recv_grid_name   receive grid name           　
  send_index       send grid index             give on the
  recv_index       receive grid index          receive component
  coef             interpolation coefficient   
  coef_sin         rotation coefficient        give on the receive component
  coef_cos         rotation coefficient        and rotation is necessary

  : Arguments of moj_set_interpolation_table
:::

## Set initial time

Give the initial time with moj_set_init_time. The argument is an integer
array of size 6, representing the year, month, day, hour, minute, and
second.

## Initial value Put

Before entering the time integration loop, the sending side must put the
data received in the first step. The API subroutine is moj_put_data or
moj_put_data_vec, and the arguments are the data name and data (one
variable for the scalar data and two variables for the vector data).

## Time integration

### Setting of current time and $\Delta{T}$

Call the API routine moj_set_time in the time integration loop and give
the current time and $\Delta{T}$. The arguments are an integer array of
size 6 representing the year, month, day, hour, minute, and second, and
an integer representing $\Delta{T}$. Note that (currently) the unit of
$\Delta{T}$ is only in seconds. Because processing inside the coupler,
such as a data exchange determination, uses the integrated value of
$\Delta{T}$, moj_set_time must be called at every step.

### Obtaining the data

To obtain the target data, call moj_get_data or moj_get_data_vec. The
argument data_name is the data name, and data, or data1, data2, is the
receiving data array. The optional argument data_scalar is a scalar
quantity received at the same time as these data, and the optional
argument data_scalar must also be given in moj_put_data of the
corresponding target component. The optional argument is_get_OK is a
logical type argument that returns whether the step is a data receiving
step.

### Putting the data

To send data, moj_put_data or moj_put_data_vec is called, which is the
same as the initial value, Put. The argument data_name is the data name,
and data, or data1 and data2, are sending data arrays. The optional
argument data_scalar is the scalar quantity to be sent at the same time
as these data. If the step is not a sending step, the processing is
appropriately conducted (sending is skipped) inside the coupler, and
thus it is not necessary for the user to make a call determination
according to the step.

## Ending process

Finally, moj_finalize is called at the end of the coupling. The argument
is_exchange_data is a flag for sending/receiving the last step data
inside moj_finalize when the last step data are not sent/received owing
to the time integration step algorithm. Here, \"is_call_finalize\" is a
flag indicating whether to call the MPI termination routine MPI_finalize
internally.

## Other main routines

### Get initial value

The subroutine moj_get_initial_data is used to obtain the initial value
from the IO component. The arguments are a data name and an array to
obtain the data. This subroutine must be called before the time
integration. In addition, it is necessary to set the reading of the
initial value in the configuration file used by the IO component.

### Get MPI information

In addition to the communicator acquisition function moj_get_comm_local,
moj_get_irank_local, which returns the rank of its own component, and
moj_get_numpe_local, which returns the number of ranks, are provided. A
subroutine moj_get_mpi_parameter for obtaining MPI information at a
particular time is also provided.

### Data exchange

Moj_send_value and moj_recv_value are provided as subroutines for
sending data to and receiving data from the target component. The
argument is a character string comp_name representing the name of the
target component and a character string, or an integer, an integer
array, a real number, or a real number array, representing a data
exchange.

### Calendar operation routine

A subroutine group for adding/subtracting the date, month, day, hour,
minute, and second according to the type of calendar and calculating the
difference between two times is provided. See the reference for details
regarding this content.

### Setting information acquisition routine

Although not required for normal use of the MOJ, there are routines that
return the settings in the configuration file for special purposes. See
the references for details on the individual routines.

### Log output routine

Here, moj_put_log outputs a Jcup format log to a Jcup log file. The
argument sub_name is the name of the subroutine, and log_str is the
character string of the log.

### Execution information acquisition routine

Here, moj_is_coupled is a function that returns whether the component
specified by the argument comp_name is currently running (coupled).

# References

## APIs of MOJ

### Public constants

The constants published by the MOJ are shown in . These are all
constants for specifying the type of calendar to be used, and are used
as arguments of the API subroutine moj_init_calendar described later.
CALENDAR_NORLAM indicates that a normal Gregorian calendar is used,
CALENDAR_NOLEAPYEAR uses a calendar fixed at 365 days a year without
leap years, and CALENDAR_30360 indicates that a calendar is fixed at 360
days a year, and 30 days a month.

[\[table:moj_constant\]]{#table:moj_constant label="table:moj_constant"}

::: {#table:moj_constant}
  name                  description　
  --------------------- ------------------------------------------------------------------------
  CALENDAR_NORMAL       Use regular Gregorian calendar
  CALENDAR_NOLEAPYEAR   Use a fixed calendar of 365 days a year without considering leap years
  CALENDAR_30360        Use a fixed calendar of 30 days a month, 360 days a year

  : Public constants of MOJ
:::

### Initialization APIs

The MOJ API subroutine group related to initialization is shown in .
Subroutine moj_init initializes the MOJ. The argument is a character
string representing the component name and the configuration file name.
This subroutine is called only once. The subroutine moj_def_grid sets
the grid used by each component. The argument grid_name represents the
name of the grid. In addition, nx, ny, and nz represent the size of the
grid assigned to the area. In a model such as CaMa, which expresses grid
points in one dimension, nx is the given grid size, and ny and nz may be
set to 1. grid_index is an integer array indicating the grid point index
of the grid in charge of its own area. This subroutine can be called
multiple times depending on the number of grid systems coupled. The
subroutine moj_end_grid_def declares the end of the grid definition.

The subroutine moj_set_interpolation_table sets the grid point
correspondence and interpolation coefficients used in an interpolation
calculation. The arguments send_comp_name, send_grid_name,
recv_comp_name, and recv_grid_name represent a send component name, a
send grid name, a receive component name, and a receive grid name,
respectively. In addition, "send_index" and "recv_index" are the grid
point indexes on the sending and receiving sides in the interpolation
calculation. The correspondence for all regions is given, and the size
of the two arrays must match. Note that this argument may be given by
the route processor of the receiving component. Here, \"coef\" is an
array corresponding to the interpolation coefficient $C$ when
calculating $R = R + S * C$, and \"coef_sin\" and \"coef_cos\" are
rotation coefficients when the rotating vector quantities are
$U = u*coef\_cos*u-coef\_sin*v$ and $V = coef\_sin*u + coef\_cos*v$. The
subroutine moj_init_time sets the initial time of the calculation. The
argument time_array(:) is an integer of size 6 representing the year,
month, day, hour, minute, and second.

Note that these subroutines must be called in the order shown in the
table.

[\[table:moj_api_initialize\]]{#table:moj_api_initialize
label="table:moj_api_initialize"}

::: {#table:moj_api_initialize}
  routine name           type of argument                     argument　                      description
  ---------------------- ------------------------------------ ------------------------------- -----------------------------
  moj_init                                                                                    
                         character(len=\*), intent(IN)        comp_name                       component name
                         character(len=\*), intent(IN)        namelist_file                   configuration file name
  moj_def_grid                                                                                
                         character(len=\*), intent(IN)        grid_name                       grid name
                         integer, intent(IN)                  nx                              number of local grid points
                                                                                              in i-direction
                         integer, intent(IN)                  ny                              number of local grid points
                                                                                              in j-direction
                         integer, intent(IN)                  nz                              number of local grid points
                                                                                              in k-direction
                         integer, intent(IN)                  grid_index(:)                   grid point index
                                                                                              of local grid
  moj_end_grid_def                                                                            
                         no argument                                                          
  moj_set\_                                                                                   
  interpolation_table    character(len=\*), intent(IN)        send_comp_name                  send component name
                         character(len=\*), intent(IN)        send_grid_name                  send grid name
                         character(len=\*), intent(IN)        recv_comp_name                  receive component name
                         character(len=\*), intent(IN)        recv_grid_name                  receive grid name
                         integer, optional, intent(IN)        send_index(:)                   grid index of
                                                                                              send component
                         integer, optional, intent(IN)        recv_index(:)                   grid index of
                                                                                              receive component
                         real(kind=8), optional, intent(IN)   coef(:)                         interpolation coefficient
                         real(kind=8), optional, intent(IN)   coef_sin(:)                     rotation coefficient(sin)
                         real(kind=8), optional, intent(IN)   coef_cos(:)                     rotation coefficient(cos)
  moj_init_time                                                                               
                         integer, intent(IN)                  time_array(:)                   integar array
                                                                                              yy/mo/dd/hh/mm/ss
  moj_get_initial_data                                                                        
                         character(len=\*), intent(IN)        data_name                       data name
                         real(kind=8), intent(INOUT)          data(:),data(:,:),data(:,:,:)   receive data
                         logical, intent(OUT)                 is_get_ok                       receive data flag

  : Initialization API of MOJ
:::

### APIs in the time integration loop

API subroutines for exchanging data in the time integration loop are
shown in . The subroutine moj_set_time is given an integer array of size
6 representing the current time and an integer representing $\Delta{T}$.
This subroutine is to be called at the beginning of the time integration
loop, and data exchanges are executed within this subroutine based on
the current time (exactly the elapsed time calculated by the summation
of $\Delta{T}$). The subroutines moj_put_data and moj_put_data_vec give
scalar or vector data to the coupler. The subroutines moj_get_data and
moj_get_data_vec are subroutines for obtaining scalar or vector data
from the coupler. The optional argument is_get_ok is a logical type
argument that returns whether the data were actually acquired when this
subroutine was called. In general, because the data exchange time
interval does not match the time step of the model component, whether
the data are acquired at that time is determined by referring to this
argument.

[\[table:moj_api_integration\]]{#table:moj_api_integration
label="table:moj_api_integration"}

::: {#table:moj_api_integration}
  routine name       type of argument                argument　                               description
  ------------------ ------------------------------- ---------------------------------------- -------------------
  moj_set_time                                                                                
                     integer, intent(IN)             time_array(:)                            current time
                     integer, intent(IN)             delta_t                                  $\Delta{T}$
  moj_put_data                                                                                
                     character(len=\*), intent(IN)   data_name                                data name
                     real(kind=8), intent(IN)        data(:) or data(:,:) or data(:,:,:)      send data
                     real(kind=8), intent(IN)        scalar_data                              send value
  moj_put_data_vec                                                                            
                     character(len=\*), intent(IN)   data_name                                data name
                     real(kind=8), intent(IN)        data1(:) or data1(:,:) or data1(:,:,:)   send data 1
                     real(kind=8), intent(IN)        data2(:) or data2(:,:) or data2(:,:,:)   send data 2
                     real(kind=8), intent(IN)        scalar_data                              send value
  moj_get_data                                                                                
                     character(len=\*), intent(IN)   data_name                                data name
                     real(kind=8), intent(INOUT)     data(:) or data(:,:) or data(:,:,:)      receive data
                     real(kind=8), intent(OUT)       scalar_data                              receive value
                     logical, intent(OUT)            is_get_ok                                data receive flag
  moj_get_data_vec                                                                            
                     character(len=\*), intent(IN)   data_name                                data name
                     real(kind=8), intent(INOUT)     data1(:) or data1(:,:) or data1(:,:,:)   receive data 1
                     real(kind=8), intent(INOUT)     data2(:) or data2(:,:) or data2(:,:,:)   receive data 2
                     real(kind=8), intent(OUT)       scalar_data                              receive value
                     logical, intent(OUT)            is_get_ok                                data receive flag

  : Data exchange APIs
:::

### Finalize API

API subroutine for coupling finalization is shown in . The subroutine
moj_finalize is called at the end of the coupling. The argument
is_exchange_data is a flag indicating whether to send and receive data
after the end of the final step, and is set according to the status of
the time step of the component. The argument is_call_finalize is a flag
indicating whether to call the MPI finalizing subroutine MPI_Finalize in
moj_finalize.

[\[table:moj_api_finalize\]]{#table:moj_api_finalize
label="table:moj_api_finalize"}

::: {#table:moj_api_finalize}
  routine name   type of argument      argument　         description
  -------------- --------------------- ------------------ -------------------------------------
  moj_finalize                                            
                 logical, intent(IN)   is_exchange_data   flag of exhcange the data or not
                 logical, intent(IN)   is_call_finalize   flag of calling MPI_finalize or not

  : Finalize API
:::

### Other APIs

Although it is possible to couple only the initialization subroutine
group, the time integration subroutine group, and the finalization
subroutine described in the previous section, utility routine groups are
provided to enhance the convenience of the MOJ. The utility routine
groups for each application are described below.

#### Query APIs of MPI setting

The functions and subroutines for obtaining MPI information are shown in
. Here, moj_get_comm_local, moj_get_irank_local, moj_get_numpe_local are
functions that return the communicator of the component, the local rank
number, and the total number of local processes, respectively. In
addition, moj_get_mpi_parameter is a subroutine for collectively
acquiring these pieces of MPI information.

[\[table:moj_api_mpi\]]{#table:moj_api_mpi label="table:moj_api_mpi"}

::: {#table:moj_api_mpi}
  routine name            type of argument       argument　   descrition
  ----------------------- ---------------------- ------------ -----------------------------
  moj_get_comm_local                                          
                          no argument                         
  moj_get_irank_local                                         
                          no argument                         
  moj_get_numpe_local                                         
                          no argument                         
  moj_get_mpi_parameter                                       
                          integer, intent(OUT)   my_comm      communicator
                          integer, intent(OUT)   my_group     groupe ID
                          integer, intent(OUT)   my_size      the number of local process
                          integer, intent(OUT)   my_ranki     local rank number

  : MPI setting of query APIs
:::

#### APIs for send/receive values

A subroutine for sending and receiving data between two components is
shown in . Here, moj_send_value sends a string, integer, or real number
to the other components. This subroutine is meaningful only to the
component's root process. In addition, moj_recv_value receives a
character string, integer, or real number from the sending component.
This subroutine must be called simultaneously on all processes of the
receiving component. Moreover, sending and receiving need to have a
one-to-one correspondence.

[\[table:moj_api_sendrecv\]]{#table:moj_api_sendrecv
label="table:moj_api_sendrecv"}

::: {#table:moj_api_sendrecv}
  routine name     type of argument                 argument　        description
  ---------------- -------------------------------- ----------------- ------------------------
  moj_send_value                                                      
                   character(len=\*), intent(IN)    comp_name         receive component name
                   character(len=\*), intent(IN)    send_string       send string
  or               integer, intent(IN)              send_inteter      send integer
  or               integer, intent(IN)              send_inteter(:)   send integer array
  or               real(kind=8), intent(IN)         send_real8        send double
  or               real(kind=8), intent(IN)         send_real8(:)     send double array
  moj_recv_value                                                      
                   character(len=\*), intent(IN)    comp_name         send component name
                   character(len=\*), intent(OUT)   recv_string       receive string
  or               integer, intent(OUT)             recv_inteter      receive integer
  or               integer, intent(OUT)             recv_inteter(:)   receive integer array
  or               real(kind=8), intent(OUT)        recv_real8        receive double
  or               real(kind=8), intent(OUT)        recv_real8(:)     receive double array

  : APIs for sending/receiving values
:::

#### Calendar APIs

The subroutine group related to a calendar calculation is shown in .
Here, moj_inc_time adds $\Delta{T}$ given by moj_set_time to the current
time. In addition, moj_init_calendar sets the type of calendar. The
argument is one of the constants CALENDAR_NORMAL, CALENDAR_NOLEAPYEAR,
or CALENDAR_30360, published in the API. Moreover, moj_inc_calendar and
moj_dec_calendar add and subtract $\Delta{T}$ to the year, month, day,
hour, minute, and second given in the first argument, and moj_inc_month
and moj_dec_month add and subtract months in the same way. In addition,
moj_cal_date_diff calculates the difference (second) between two years,
months, days, hours, minutes, and seconds, and moj_get_month_date
returns the number of days in a certain year and month.

[\[table:moj_api_calendar\]]{#table:moj_api_calendar
label="table:moj_api_calendar"}

::: {#table:moj_api_calendar}
  routine name         type of argument         argument         description
  -------------------- ------------------------ ---------------- ----------------------------
  moj_inc_time                                                   
                       integer, intent(INOUT)   time_array(6)    array of yy/mo/dd/hh/mm/ss
  moj_init_calendar                                              
                       integer, intent(IN)      calendar_type    one of CALENDAR_NORMAL,
                                                                 CALENDAR_NOLEAPLEAY,
                                                                 CALENDAR_30360
  moj_inc_calendar                                               
                       integer, intent(INOUT)   time_array(6)    array of yy/mo/dd/hh/mm/ss
                       integer, intent(IN)      delta_t          seconds to add
  moj_dec_calendar                                               
                       integer, intent(INOUT)   time_array(6)    array of yy/mo/dd/hh/mm/ss
                       integer, intent(IN)      delta_t          senconds to subtruct
  moj_inc_month                                                  
                       integer, intent(INOUT)   time_array(6)    array of yy/mo/dd/hh/mm/ss
                       integer, intent(IN)      delta_m          months to add
  moj_dec_calendar                                               
                       integer, intent(INOUT)   time_array(6)    array of yy/mo/dd/hh/mm/ss
                       integer, intent(IN)      delta_m          months to subtruct
  moj_cal_date_diff                                              
                       integer, intent(IN)      time_array1(6)   array of yy/mo/dd/hh/mm/ss
                       integer, intent(IN)      time_array2(6)   array of yy/mo/dd/hh/mm/ss
                       integer, intent(OUT)     deff_sec         array2-array1(seconds)
  moj_get_month_date                                             
                       integer, intent(IN)      year             year
                       integer, intent(IN)      month            month

  : APIs for calendar calculation
:::

#### Query APIs of configuration

shows the subroutine group for acquiring the setting information. These
are subroutines for acquiring information defined in the configuration
file described in the Preparation section. In each case, the data
exchange interval and the data tag for interpolation calculation are
acquired from the send component name and the data name, or from the
receive component name and the data name.

[\[table:moj_api_config\]]{#table:moj_api_config
label="table:moj_api_config"}

::: {#table:moj_api_config}
  routine name            type of argument                 argument　      description
  ----------------------- -------------------------------- --------------- ----------------------------
  moj_get\_                                                                
  exchange_interval_put   character(len=\*), intent(IN)    put_comp_name   send component name
                          character(len=\*), intent(IN)    put_data_name   send data name
                          integer, intent(OUT)             intvl           exchange interval(seconds)
  moj_get\_                                                                
  exchange_interval_get   character(len=\*), intent(IN)    get_comp_name   receive component name
                          character(len=\*), intent(IN)    get_data_name   receive data name
                          integer, intent(OUT)             intvl           exchange interval(seconds)
  moj_get_grid_tag_put                                                     
                          character(len=\*), intent(IN)    put_comp_name   send component name
                          character(len=\*), intent(IN)    put_data_name   send data name
                          integer, intent(OUT)             tag             spacial interpolation tag
  moj_get_grid_tag_get                                                     
                          character(len=\*), intent(IN)    get_comp_name   receive component name
                          character(len=\*), intent(IN)    get_data_name   receive data name
                          integer, intent(OUT)             tag             spacial interpolation tag
  moj_get_time_tag_put                                                     
                          character(len=\*), intent(IN)    put_comp_name   send component name
                          character(len=\*), intent(IN)    put_data_name   send data name
                          integer, intent(OUT)             tag             time interpolation tag
  moj_get_time_tag_get                                                     
                          character(len=\*), intent(IN)    get_comp_name   receive component name
                          character(len=\*), intent(IN)    get_data_name   receive data name
                          integer, intent(OUT)             tag             time interpolation tag
  moj_get_get_comp_name                                                    
                          character(len=\*), intent(IN)    put_comp_name   send component name
                          character(len=\*), intent(IN)    put_data_name   send data name
                          character(len=\*), intent(OUT)   get_comp_name   receive component name

  : Query APIs of configuration information
:::

#### Log output API

shows the subroutine that outputs a Jcup format log to a Jcup log file.
The argument sub_name is the name of the subroutine, and log_str is a
character string to be output.

[\[table:moj_api_log\]]{#table:moj_api_log label="table:moj_api_log"}

::: {#table:moj_api_log}
  routine name   type of argument                argument　   description
  -------------- ------------------------------- ------------ -----------------
  moj_put_log                                                 
                 character(len=\*), intent(IN)   sub_name     subroutine name
                 character(len=\*), intent(IN)   log_str      log string

  : Log output API
:::

#### Execution information query API

shows the function that returns whether the component specified by the
argument is currently being executed (coupled). The argument comp_name
is the name of the target component.

[\[table:moj_api_coupled\]]{#table:moj_api_coupled
label="table:moj_api_coupled"}

::: {#table:moj_api_coupled}
  routine name     type of argument                argument　   description
  ---------------- ------------------------------- ------------ ----------------
  moj_is_coupled                                                
                   character(len=\*), intent(IN)   comp_name    component name

  : API for execution informatioin
:::
